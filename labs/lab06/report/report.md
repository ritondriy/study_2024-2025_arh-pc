---
## Front matter
title: "Отчёт по лабораторной работе №6"
subtitle: "диспилина: архитектура компьютера"
author: "Терещенкова Маргарита Владимировна"

## Generic otions
lang: ru-RU
toc-title: "Содержание"

## Bibliography
bibliography: bib/cite.bib
csl: pandoc/csl/gost-r-7-0-5-2008-numeric.csl

## Pdf output format
toc: true # Table of contents
toc-depth: 2
lof: true # List of figures
fontsize: 12pt
linestretch: 1.5
papersize: a4
documentclass: scrreprt
## I18n polyglossia
polyglossia-lang:
  name: russian
  options:
	- spelling=modern
	- babelshorthands=true
polyglossia-otherlangs:
  name: english
## I18n babel
babel-lang: russian
babel-otherlangs: english
## Fonts
mainfont: IBM Plex Serif
romanfont: IBM Plex Serif
sansfont: IBM Plex Sans
monofont: IBM Plex Mono
mathfont: STIX Two Math
mainfontoptions: Ligatures=Common,Ligatures=TeX,Scale=0.94
romanfontoptions: Ligatures=Common,Ligatures=TeX,Scale=0.94
sansfontoptions: Ligatures=Common,Ligatures=TeX,Scale=MatchLowercase,Scale=0.94
monofontoptions: Scale=MatchLowercase,Scale=0.94,FakeStretch=0.9
mathfontoptions:
## Biblatex
biblatex: true
biblio-style: "gost-numeric"
biblatexoptions:
  - parentracker=true
  - backend=biber
  - hyperref=auto
  - language=auto
  - autolang=other*
  - citestyle=gost-numeric
## Pandoc-crossref LaTeX customization
figureTitle: "Рис."
tableTitle: "Таблица"
listingTitle: "Листинг"
lofTitle: "Список иллюстраций"
lolTitle: "Листинги"
## Misc options
indent: true
header-includes:
  - \usepackage{indentfirst}
  - \usepackage{float} # keep figures where there are in the text
  - \floatplacement{figure}{H} # keep figures where there are in the text
---

# Цель работы

Освоение арифметических инструкций языка ассемблера NASM.

# Задание

    1. Символьные и численные данные в NASM
    2. Выполнение арифметических операций в NASM
    3. Выполнение заданий для самостоятельной работы

# Теоретическое введение

Большинство инструкций на языке ассемблера требуют обработки операндов. Адрес операнда предоставляет место, где хранятся данные, подлежащие обработке. Это могут быть данные хранящиеся в регистре или в ячейке памяти. - Регистровая адресация – операнды хранятся в регистрах и в команде используются имена этих регистров, например: mov ax,bx. - Непосредственная адресация – значение операнда задается непосредственно в команде, Например: mov ax,2. - Адресация памяти – операнд задает адрес в памяти. В команде указывается символическое обозначение ячейки памяти, над содержимым которой требуется выполнить операцию.

Ввод информации с клавиатуры и вывод её на экран осуществляется в символьном виде. Кодирование этой информации производится согласно кодовой таблице символов ASCII. ASCII – сокращение от American Standard Code for Information Interchange (Американский стандартный код для обмена информацией). Согласно стандарту ASCII каждый символ кодируется одним байтом. Среди инструкций NASM нет такой, которая выводит числа (не в символьном виде). Поэтому, например, чтобы вывести число, надо предварительно преобразовать его цифры в ASCII-коды этих цифр и выводить на экран эти коды, а не само число. Если же выводить число на экран непосредственно, то экран воспримет его не как число, а как последовательность ASCII-символов – каждый байт числа будет воспринят как один ASCII-символ – и выведет на экран эти символы. Аналогичная ситуация происходит и при вводе данных с клавиатуры. Введенные данные будут представлять собой символы, что сделает невозможным получение корректного результата при выполнении над ними арифметических операций. Для решения этой проблемы необходимо проводить преобразование ASCII символов в числа и обратно.

# Выполнение лабораторной работы

## Символьные и численные данные в NASM

1. Создаю каталог для программам лабораторной работы № 6 (lab06) с помощью утилиты **mkdir**, перехожу в него и
создаю файл lab6-1.asm с помощью утилиты **touch**.

![Создание директории и файла](/home/mvtereshenkova/Рабочий стол/rudn/архитектура компьютеров/лаба 6/архив6/photo1.jpg){#fig:001 width=70%}

Копирую в текущий каталог файл in_out.asm с помощью утилиты cp, т.к. он будет использоваться в других программах. И проверяю наличие файла в данной директори с помощью команды **ls**.

![Копирование файла](/home/mvtereshenkova/Рабочий стол/rudn/архитектура компьютеров/лаба 6/архив6/photo2.jpg){#fig:002 width=70%}

2. Открываю созданный файл lab6-1.asm, вставляю в него программу вывода значения регистра eax.

![Редактирование файла](/home/mvtereshenkova/Рабочий стол/rudn/архитектура компьютеров/лаба 6/архив6/photo3.jpg){#fig:003 width=70%}

Создаю исполняемый файл программы и запускаю его. 

![Запуск исполняемого файла](/home/mvtereshenkova/Рабочий стол/rudn/архитектура компьютеров/лаба 6/архив6/photo4.jpg){#fig:004 width=70%}

Вывод программы: символ **j**, потому что программа вывела символ, соответствующий по системе ASCII сумме двоичных кодов символов 4 и 6.

3. Изменяю текст программы и вместо символов, запишем в регистры числа (“6” и “4” на цифры 6 и 4).

![Редактирование файла](/home/mvtereshenkova/Рабочий стол/rudn/архитектура компьютеров/лаба 6/архив6/photo5.jpg){#fig:005 width=70%}

Создаю новый исполняемый файл программы и запускаю его. 

![Запуск исполняемого файла](/home/mvtereshenkova/Рабочий стол/rudn/архитектура компьютеров/лаба 6/архив6/photo6.jpg){#fig:006 width=70%}

Теперь вывелся символ с кодом 10, это символ перевода строки, этот символ не отображается при выводе на экран.

4. Создаю новый файл lab6-2.asm с помощью утилиты **touch**.

![Создание файла](/home/mvtereshenkova/Рабочий стол/rudn/архитектура компьютеров/лаба 6/архив6/photo7.jpg){#fig:007 width=70%}

Ввожу в файл текст другой программы для вывода значения регистра eax.

![Редактирование файла](/home/mvtereshenkova/Рабочий стол/rudn/архитектура компьютеров/лаба 6/архив6/photo8.jpg){#fig:008 width=70%}

Создаю и запускаю исполняемый файл lab6-2. 

![Запуск исполняемого файла](/home/mvtereshenkova/Рабочий стол/rudn/архитектура компьютеров/лаба 6/архив6/photo9.jpg){#fig:009 width=70%}

Теперь выводится число **106**, потому что программа позволяет вывести именно число, а не символ, хотя все еще происходит именно сложение кодов символов “6” и “4”.

5. Аналогично предыдущему примеру изменила символы на числа. (“6” и “4” на 6 и 4 ).

![Редактирование файла](/home/mvtereshenkova/Рабочий стол/rudn/архитектура компьютеров/лаба 6/архив6/photo10.jpg){#fig:010 width=70%}

Создаю и запускаю новый исполняемый файл. 

![Запуск исполняемого файла](/home/mvtereshenkova/Рабочий стол/rudn/архитектура компьютеров/лаба 6/архив6/photo11.jpg){#fig:011 width=70%}

Теперь программа складывает не соответствующие символам коды в системе ASCII, а сами числа, поэтому вывод 10.

Заменяю в тексте программы функцию **iprintLF** на **iprint**.

![Редактирование файла](/home/mvtereshenkova/Рабочий стол/rudn/архитектура компьютеров/лаба 6/архив6/photo12.jpg){#fig:012 width=70%}

Создаю и запускаю новый исполняемый файл. 

![Запуск исполняемого файла](/home/mvtereshenkova/Рабочий стол/rudn/архитектура компьютеров/лаба 6/архив6/photo13.jpg){#fig:013 width=70%}

**iprint** не добавляет к выводу символ переноса строки, в отличие от **iprintLF**.

## Выполнение арифметических операций в NASM

6. Создаю файл lab6-3.asm с помощью утилиты **touch**.

![Создание файла](/home/mvtereshenkova/Рабочий стол/rudn/архитектура компьютеров/лаба 6/архив6/photo14.jpg){#fig:014 width=70%}

Ввожу в созданный файл текст программы для вычисления значения выражения *f(x)* = (5 * 2 + 3)/3

![Редактирование файла](/home/mvtereshenkova/Рабочий стол/rudn/архитектура компьютеров/лаба 6/архив6/photo15.jpg){#fig:015 width=70%}

Создаю исполняемый файл и запускаю его.

![Запуск исполняемого файла](/home/mvtereshenkova/Рабочий стол/rudn/архитектура компьютеров/лаба 6/архив6/photo16.jpg){#fig:016 width=70%}

Изменяю программу так, чтобы она вычисляла значение выражения *f(x)* = (4 * 6 + 2)/5.

![Редактирование программы](/home/mvtereshenkova/Рабочий стол/rudn/архитектура компьютеров/лаба 6/архив6/photo17.jpg){#fig:017 width=70%}

Создаю и запускаю новый исполняемый файл. 

![Запуск исполняемого файла](/home/mvtereshenkova/Рабочий стол/rudn/архитектура компьютеров/лаба 6/архив6/photo18.jpg){#fig:018 width=70%}

Я посчитала для проверки правильности работы программы значение выражения самостоятельно, программа отработала верно.

7. Создаю файл numbervariant.asm с помощью утилиты **touch**.

![Создание файла](/home/mvtereshenkova/Рабочий стол/rudn/архитектура компьютеров/лаба 6/архив6/photo19.jpg){#fig:019 width=70%}

Ввожу в файл текст программы для вычисления варианта задания по номеру студенческого билета.

![Редактирование программы](/home/mvtereshenkova/Рабочий стол/rudn/архитектура компьютеров/лаба 6/архив6/photo20.jpg){#fig:020 width=70%}

Создаю и запускаю исполняемый файл. Ввожу номер своего студ. билета с клавиатуры. 

![Запуск исполняемого программы](/home/mvtereshenkova/Рабочий стол/rudn/архитектура компьютеров/лаба 6/архив6/photo21.jpg){#fig:021 width=70%}

Программа вывела, что мой вариант - 4.

## Ответы на вопросы по программе.

1.  За вывод сообщения “Ваш вариант” отвечают строки кода:

**mov eax,rem**

**call sprint**

2. **mov ecx, x** используется, чтобы положить адрес вводимой строки x в регистр 

   **ecx mov edx, 80** - запись в регистр edx длины вводимой строки 

   **call sread ** - вызов подпрограммы из внешнего файла, обеспечивающей ввод сообщения с клавиатуры

3. **call atoi** используется для вызова подпрограммы из внешнего файла, которая преобразует ASCII-код символа в целое число и записывает результат в регистр eax.

4. За вычисления варианта отвечают строки:

**xor edx,edx** *; обнуление edx для корректной работы div*

**mov ebx,20** *; ebx = 20*

**div ebx** *; eax = eax/20, edx - остаток от деления*

**inc edx** *; edx = edx + 1*

5. При выполнении инструкции **div ebx** остаток от деления записывается в регистр edx.
    
6. Инструкция **inc edx** увеличивает значение регистра edx на 1.

7. За вывод на экран результатов вычислений отвечают строки:

**mov eax,edx**

**call iprintLF**

# Выполнение самостоятельной работы

Создаю файл lab6-4.asm .

![Создание файла](/home/mvtereshenkova/Рабочий стол/rudn/архитектура компьютеров/лаба 6/архив6/photo22.jpg){#fig:022 width=70%}

Открываю созданный файл для редактирования, ввожу в него текст программы для вычисления значения выражения 4/3*(x-1)+5 . Это выражение было под вариантом 4.

![Написание программы](/home/mvtereshenkova/Рабочий стол/rudn/архитектура компьютеров/лаба 6/архив6/photo23.jpg){#fig:023 width=70%}

Создаю и запускаю исполняемый файл 2 раза. Ввожу значение переменных x, которые написаны в моём варианте, а именно  *x1=4* и *x2=10*.

![Запуск исполняемого программы](/home/mvtereshenkova/Рабочий стол/rudn/архитектура компьютеров/лаба 6/архив6/photo24.jpg){#fig:024 width=70%}

Программа выводит верный ответ, учитывая, что при выполнении деления в качестве результата можно использовать только целую часть от деления и не учитывать остаток (т.е. 5 ∶ 2 = 2).

**Листинг** *Программа для вычисления значения выражения* 4/3*(x-1)+5.

%include 'in_out.asm' 

SECTION .data

msg db 'Введите значение переменной x: ', 0 
 
rem db 'Результат: ', 0                       

SECTION .bss

x RESB 80   

SECTION .text

GLOBAL _start

_start:

mov eax, msg 
 
call sprint   

mov ecx, x  
  
mov edx, 80 
  
call sread    

mov eax, x 
   
call atoi   

; f(x) = (3 / 4) * (x - 1) + 5

sub eax, 1    ; eax = x - 1

mov ebx, 3    ; Умножаем на 3

imul eax, ebx ; eax = (x - 1) * 3

mov ebx, 4    ; Делим на 4

xor edx, edx  ; Обнуляем edx перед делением

div ebx       ; eax = (x - 1) * 3 / 4

add eax, 5    ; eax = (x - 1) * 3 / 4 + 5

mov edi, eax 
 
mov eax, rem 
 
call sprint 
  
mov eax, edi 
 
call iprintLF
   
call quit 

# Выводы

Благодаря данной лабораторной работе освоила арифметических инструкций языка ассемблера NASM.

# Список литературы{.unnumbered}

    1. Лабораторная работа №6
    2. Таблица ASCII

::: {#refs}
:::
